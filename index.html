<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxel Pocket - Economy Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body { margin: 0; overflow: hidden; background: #000; touch-action: none; user-select: none; font-family: 'Press Start 2P', cursive; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center;
        }
        #crosshair::before { content: ''; position: absolute; width: 16px; height: 2px; background: rgba(255,255,255,0.8); mix-blend-mode: difference; }
        #crosshair::after { content: ''; position: absolute; width: 2px; height: 16px; background: rgba(255,255,255,0.8); mix-blend-mode: difference; }

        #break-progress {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            border: 4px solid rgba(0,0,0,0.5); border-top-color: #fff; border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 10; transition: transform 0.1s linear;
        }

        .corner-btn {
            position: absolute; top: 10px; width: 36px; height: 36px;
            background: rgba(0,0,0,0.5); border: 2px solid #fff; color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 7px; cursor: pointer; pointer-events: auto;
            box-shadow: 0 3px 0 rgba(0,0,0,0.3); z-index: 100;
        }
        #pause-btn { left: 10px; }
        #chat-toggle-btn { left: 52px; }
        #shop-btn { left: 94px; background: #d4af37; color: #000; border-color: #ffd700; }
        
        #coin-display {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: #ffd700; text-shadow: 2px 2px #000; font-size: 10px;
            background: rgba(0,0,0,0.6); padding: 5px 10px; border: 2px solid #ffd700;
        }

        #fs-btn { right: 52px; } 
        #cam-btn { right: 10px; }
        .corner-btn:active { transform: translateY(2px); box-shadow: none; }

        #hotbar-container {
            position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 2px; background: rgba(0,0,0,0.4); padding: 2px; border: 3px solid #111; pointer-events: auto;
            max-width: 95vw; overflow-x: auto;
        }
        .slot {
            width: 34px; height: 34px; border: 3px solid #555; background: #8B8B8B;
            display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative;
            box-shadow: inset 2px 2px #AAA, inset -2px -2px #333; flex-shrink: 0;
        }
        .slot.active { border-color: #FFF; background: #AAA; z-index: 2; transform: scale(1.05); box-shadow: 0 0 8px white; }
        .slot canvas { width: 24px; height: 24px; image-rendering: pixelated; pointer-events: none; }
        .count-badge { position: absolute; bottom: 0; right: 0; font-size: 8px; color: white; text-shadow: 1px 1px 0 #000; pointer-events: none;}
        
        #inv-btn {
            width: 34px; height: 34px; background: #8B8B8B; border: 3px solid #111; color: #fff;
            display: flex; align-items: center; justify-content: center; font-size: 7px;
            margin-right: 3px; cursor: pointer; text-shadow: 1px 1px #000;
            box-shadow: inset 2px 2px #AAA, inset -2px -2px #333; flex-shrink: 0;
        }

        .ctrl { position: absolute; pointer-events: auto; z-index: 50; display: none; }
        #joy-zone { bottom: 20px; left: 15px; width: 110px; height: 110px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; }
        #joy-nub { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: #fff; border-radius: 50%; transform: translate(-50%, -50%); opacity: 0.4; pointer-events: none; }
        
        #flight-controls {
            position: absolute; bottom: 20px; right: 15px;
            display: flex; flex-direction: column; gap: 8px; align-items: center;
        }
        .action-btn {
            width: 50px; height: 50px; border-radius: 50%;
            background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.4);
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(2px);
        }
        .action-btn svg { width: 24px; height: 24px; fill: white; opacity: 0.8; }

        #chat-container {
            position: fixed; top: 55px; left: 10px; width: 240px; height: 180px;
            display: none; flex-direction: column; z-index: 2500; pointer-events: auto;
        }
        #chat-header { background: rgba(0,0,0,0.8); color: #0f0; padding: 4px; font-size: 6px; border-bottom: 2px solid #333; }
        #chat-log { flex-grow: 1; background: rgba(0,0,0,0.6); color: #fff; padding: 6px; font-size: 7px; overflow-y: auto; display: flex; flex-direction: column-reverse; }
        #chat-input-wrapper { display: flex; background: rgba(0,0,0,0.8); border: 2px solid #555; }
        #chat-input { flex-grow: 1; background: transparent; border: none; color: #fff; padding: 8px; font-family: 'Press Start 2P'; font-size: 7px; outline: none; width: 50%; }
        #chat-send-btn { background: #555; color: #fff; border: none; padding: 0 8px; cursor: pointer; font-family: 'Press Start 2P'; font-size: 7px; }

        #inventory-overlay, #shop-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; pointer-events: auto; }
        #inventory-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; background: #8B8B8B; padding: 15px; border: 4px solid #111; max-height: 60vh; overflow-y: auto; }
        
        #pause-menu { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000; pointer-events: auto; }
        .menu-card { background: #8B8B8B; padding: 20px; border: 4px solid #000; display: flex; flex-direction: column; gap: 10px; width: 200px; }
        .menu-btn { padding: 12px; background: #777; color: #fff; border: 3px solid #000; font-family: 'Press Start 2P'; font-size: 9px; cursor: pointer; text-align: center; }

        #shop-content { background: #8B8B8B; padding: 15px; border: 4px solid #ffd700; width: 80%; max-height: 80%; overflow-y: auto; display: flex; flex-direction: column; }
        .shop-tab-bar { display: flex; gap: 5px; margin-bottom: 10px; }
        .shop-tab { flex: 1; padding: 10px; background: #555; color: white; cursor: pointer; border: 2px solid #000; font-size: 8px; text-align: center; }
        .shop-tab.active { background: #ffd700; color: black; }
        .shop-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; }
        .shop-item { background: #666; padding: 5px; border: 2px solid #000; display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; }
        .shop-item:hover { background: #777; }
        .shop-price { color: #ffd700; font-size: 7px; }
        .sell-btn { background: #a33; border: 1px solid #fff; padding: 2px; font-size: 6px; width: 100%; text-align: center; cursor: pointer; margin-top: 2px;}

        #delete-toggle { margin-bottom: 10px; padding: 10px; border: 2px solid white; background: #333; color: white; cursor: pointer; font-size: 8px; }
        #delete-toggle.active { background: #a33; border-color: red; }

        #loading { position: fixed; inset: 0; background: #111; color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #start-btn { padding: 12px 30px; font-family: 'Press Start 2P'; font-size: 12px; cursor: pointer; background: #777; color: #fff; border: 4px solid #000; margin-top: 15px; display: none;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/SkeletonUtils.js"></script>
</head>
<body>
    <div id="loading">
        <h1 style="font-size: 18px; text-shadow: 3px 3px #555; text-align: center;">VOXEL POCKET<br><span style="font-size: 10px; color: gold;">ECONOMY EDITION</span></h1>
        <p id="loading-text" style="font-size: 7px; color: #aaa; margin-top: 10px;">INITIALIZING...</p>
        <button id="start-btn">ENTER WORLD (GOOGLE LOGIN)</button>
    </div>

    <div id="ui">
        <div id="crosshair"></div>
        <div id="break-progress"></div>
        <div id="coin-display">COINS: <span id="coin-count">0</span></div>
        
        <div id="pause-btn" class="corner-btn ctrl">||</div>
        <div id="chat-toggle-btn" class="corner-btn ctrl">MSG</div>
        <div id="shop-btn" class="corner-btn ctrl">$</div>
        <div id="fs-btn" class="corner-btn ctrl">FULL</div>
        <div id="cam-btn" class="corner-btn ctrl">POV</div>

        <div id="chat-container">
            <div id="chat-header">ID: <span id="user-display-id">...</span></div>
            <div id="chat-log"></div>
            <div id="chat-input-wrapper">
                <input type="text" id="chat-input" placeholder="..." maxlength="50">
                <button id="chat-send-btn">></button>
            </div>
        </div>

        <div id="hotbar-container">
            <div id="inv-btn">INV</div>
            <div id="hotbar-slots" style="display: flex; gap: 2px;"></div>
        </div>
        <div id="joy-zone" class="ctrl"><div id="joy-nub"></div></div>
        
        <div id="flight-controls" class="ctrl">
            <div id="up-btn" class="action-btn" style="display: none;">
                <svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
            </div>
            <div id="jump-btn" class="action-btn">
                <svg viewBox="0 0 24 24"><path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/></svg>
            </div>
            <div id="down-btn" class="action-btn" style="display: none;">
                <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
            </div>
        </div>
    </div>

    <div id="pause-menu">
        <div class="menu-card">
            <div style="text-align: center; margin-bottom: 5px; color: #fff; text-shadow: 2px 2px #000; font-size: 10px;">PAUSED</div>
            <div id="resume-btn" class="menu-btn">RESUME</div>
            <div id="quit-btn" class="menu-btn" style="background: #a33;">QUIT</div>
        </div>
    </div>

    <div id="inventory-overlay">
        <div style="color: white; margin-bottom: 10px; font-size: 10px;">INVENTORY (30 SLOTS)</div>
        <div id="delete-toggle">DELETE MODE: OFF</div>
        <div id="inventory-grid"></div>
        <button id="close-inv" class="menu-btn" style="margin-top: 15px; width: 160px;">CLOSE</button>
    </div>

    <div id="shop-overlay">
        <div id="shop-content">
            <div class="shop-tab-bar">
                <div class="shop-tab active" data-tab="blocks">BLOCKS</div>
                <div class="shop-tab" data-tab="tools">TOOLS</div>
                <div class="shop-tab" data-tab="skins">SKINS</div>
            </div>
            <div id="shop-items-container" class="shop-grid"></div>
            <button id="close-shop" class="menu-btn" style="margin-top: 15px; align-self: center; width: 100px;">CLOSE</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, browserLocalPersistence, setPersistence } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, orderBy, limit, setDoc, doc, serverTimestamp, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBgQaeWlxecgunDZo8xHBorRVIrZ8K4YJ8",
            authDomain: "pixelbox-bca1b.firebaseapp.com",
            projectId: "pixelbox-bca1b",
            storageBucket: "pixelbox-bca1b.firebasestorage.app",
            messagingSenderId: "709778027442",
            appId: "1:709778027442:web:c2959397d3285e1f24eaab",
            measurementId: "G-8B9GQFDVY1"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const APP_ID = 'pixelbox_eco_v2'; 

        const CHUNK_SIZE = 16;
        const RENDER_DIST = 3;
        const PLAYER_HEIGHT = 1.62;
        const PLAYER_RADIUS = 0.3;
        const DAY_LENGTH_SECONDS = 300; 
        const MOVE_THRESHOLD = 15;
        const CLAIM_BLOCK_ID = 99;

        let currentUser = null;
        let userId = 'Guest';
        let userDisplayName = 'Guest';
        let otherPlayers = {}; 
        let ATLAS_COLS = 8;
        let ATLAS_ROWS = 8;
        let playerCoins = 0;
        let playerInventory = new Array(30).fill(null).map(() => ({ id: 0, count: 0 })); 
        let landClaims = {}; 
        let myClaims = 0;
        let activeTool = { id: 'hand', speed: 1.0, name: 'Hand' };
        let activeSkin = 'robot';
        let deleteMode = false;

        // Prices: Log=2, Stone=2, Coal=3, Iron=4, Gold=5, Diamond=6, DiamondBlock=20
        const BLOCKS = {
            1: { name: 'Grass',  price: 2, hardness: 0.6, files: ['grass_side.png', 'grass_side.png', 'grass_top.png', 'dirt.png', 'grass_side.png', 'grass_side.png'] },
            2: { name: 'Dirt',   price: 1, hardness: 0.5, files: ['dirt.png', 'dirt.png', 'dirt.png', 'dirt.png', 'dirt.png', 'dirt.png'] },
            3: { name: 'Stone',  price: 2, hardness: 1.5, files: ['stone.png', 'stone.png', 'stone.png', 'stone.png', 'stone.png', 'stone.png'] },
            4: { name: 'Log',    price: 2, hardness: 2.0, files: ['log_side.png', 'log_side.png', 'log_top.png', 'log_top.png', 'log_side.png', 'log_side.png'] },
            5: { name: 'Leaves', price: 1, hardness: 0.2, files: ['leaves.png', 'leaves.png', 'leaves.png', 'leaves.png', 'leaves.png', 'leaves.png'], transparent: true },
            6: { name: 'Sand',   price: 1, hardness: 0.5, files: ['sand.png', 'sand.png', 'sand.png', 'sand.png', 'sand.png', 'sand.png'] },
            7: { name: 'Planks', price: 4, hardness: 2.0, files: ['planks.png', 'planks.png', 'planks.png', 'planks.png', 'planks.png', 'planks.png'] },
            8: { name: 'Glass',  price: 5, hardness: 0.3, files: ['glass.png', 'glass.png', 'glass.png', 'glass.png', 'glass.png', 'glass.png'], transparent: true },
            9: { name: 'Bedrock', files: ['bedrock.png', 'bedrock.png', 'bedrock.png', 'bedrock.png', 'bedrock.png', 'bedrock.png'], indestructible: true },
            10: { name: 'Torch', price: 5, hardness: 0.1, files: ['torch.png', 'torch.png', 'torch.png', 'torch.png', 'torch.png', 'torch.png'], isTorch: true, light: 0xFFA500, transparent: true },
            11: { name: 'Water', files: ['water.png', 'water.png', 'water.png', 'water.png', 'water.png', 'water.png'], transparent: true, isFluid: true, opacity: 0.7 },
            12: { name: 'Coal Ore', price: 3, hardness: 3.0, isOre: true, rarity: 100, files: ['coal_ore.png', 'coal_ore.png', 'coal_ore.png', 'coal_ore.png', 'coal_ore.png', 'coal_ore.png'] },
            13: { name: 'Iron Ore', price: 4, hardness: 4.0, isOre: true, rarity: 60, files: ['iron_ore.png', 'iron_ore.png', 'iron_ore.png', 'iron_ore.png', 'iron_ore.png', 'iron_ore.png'] },
            14: { name: 'Gold Ore', price: 5, hardness: 5.0, isOre: true, rarity: 30, files: ['gold_ore.png', 'gold_ore.png', 'gold_ore.png', 'gold_ore.png', 'gold_ore.png', 'gold_ore.png'] },
            15: { name: 'Diamond Ore', price: 6, hardness: 6.0, isOre: true, rarity: 10, files: ['diamond_ore.png', 'diamond_ore.png', 'diamond_ore.png', 'diamond_ore.png', 'diamond_ore.png', 'diamond_ore.png'] },
            17: { name: 'Cobblestone', price: 1, hardness: 2.0, files: ['cobblestone.png', 'cobblestone.png', 'cobblestone.png', 'cobblestone.png', 'cobblestone.png', 'cobblestone.png'] },
            35: { name: 'Crafting Table', price: 10, hardness: 2.5, files: ['crafting_side.png', 'crafting_side.png', 'crafting_top.png', 'planks.png', 'crafting_side.png', 'crafting_side.png'] },
            54: { name: 'Diamond Block', price: 20, hardness: 8.0, isOre: true, rarity: 1, files: ['diamond_block.png', 'diamond_block.png', 'diamond_block.png', 'diamond_block.png', 'diamond_block.png', 'diamond_block.png'] },
            99: { name: 'Claim Block', price: 500, hardness: 10.0, files: ['gold_block.png', 'gold_block.png', 'obsidian.png', 'obsidian.png', 'gold_block.png', 'gold_block.png'] }
        };

        const TOOLS = [
            { id: 'wood_pick', name: 'Wood Pick', cost: 50, speed: 1.5 },
            { id: 'stone_pick', name: 'Stone Pick', cost: 150, speed: 2.5 },
            { id: 'iron_pick', name: 'Iron Pick', cost: 500, speed: 4.0 },
            { id: 'diamond_pick', name: 'Diamond Pick', cost: 1000, speed: 8.0 }
        ];

        const SKINS = [
            { id: 'robot', name: 'Classic Robot', cost: 0, file: 'RobotExpressive.glb' },
            { id: 'soldier', name: 'Soldier', cost: 500, file: 'Soldier.glb' } 
        ];

        let scene, camera, renderer, raycaster, atlas, sunLight, ambientLight, clouds, stars;
        let playerGroup, externalModel, cameraPivot, modelLoaded = false;
        let world = {}, chunkMeshes = {}, clickables = [];
        let activeTorches = []; 

        let vel = new THREE.Vector3(), onGround = false, gameTime = 0, running = false, paused = false;
        let isTouch = 'ontouchstart' in window;
        let activeHotbarIndex = 0;
        let hotbarSlots = [0, 0, 0, 0, 0, 0, 0, 0]; 
        let selectionBox;
        const keys = {}, joy = { x: 0, y: 0, id: null, sx: 0, sy: 0 };
        const touchState = { id: null, lx: 0, ly: 0, sx: 0, sy: 0, timer: null, moved: false, startTime: 0, mineStart: 0 };

        let isFlying = false, lastJumpTime = 0, isTouchingDown = false, isTouchingUp = false, povMode = 0, povDist = 4;
        let mixer, actions = {}, activeAction;

        function makeTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            context.font = "Bold 40px sans-serif";
            context.fillStyle = "rgba(0,0,0,0.5)";
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            context.beginPath(); context.roundRect(256 - textWidth/2 - 15, 40, textWidth + 30, 50, 10); context.fill();
            context.textAlign = "center"; context.textBaseline = "middle";
            context.fillStyle = "white"; context.strokeStyle = "black"; context.lineWidth = 4;
            context.strokeText(message, 256, 65); context.fillText(message, 256, 65);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(2, 0.5, 1);
            return sprite;
        }

        function initNetwork() {
            const playersRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'players');
            onSnapshot(playersRef, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const pid = change.doc.id;
                    if (pid === userId) return; 
                    if (change.type === "added" || change.type === "modified") {
                        if (!otherPlayers[pid]) createRemotePlayer(pid, data);
                        updateRemotePlayer(pid, data);
                    }
                    if (change.type === "removed") removeRemotePlayer(pid);
                });
            });

            const worldRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'world_changes');
            const q = query(worldRef, orderBy('timestamp', 'asc'));
            onSnapshot(q, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const d = change.doc.data();
                        const key = `${Math.floor(d.x)},${Math.floor(d.y)},${Math.floor(d.z)}`;
                        if (d.action === 'PLACE') {
                            world[key] = d.id;
                            if (d.id === 10) activeTorches.push({x:d.x, y:d.y, z:d.z, k:key});
                            if (d.id === CLAIM_BLOCK_ID) {
                                const cx = Math.floor(d.x/16), cz = Math.floor(d.z/16);
                                landClaims[`${cx},${cz}`] = d.author;
                            }
                        } else if (d.action === 'BREAK') {
                            const prev = world[key];
                            world[key] = 0;
                            if (prev === 10) activeTorches = activeTorches.filter(t => t.k !== key);
                            if (prev === CLAIM_BLOCK_ID) {
                                const cx = Math.floor(d.x/16), cz = Math.floor(d.z/16);
                                delete landClaims[`${cx},${cz}`];
                            }
                        }
                        if (running) refreshChunk(d.x, d.z);
                    }
                });
            });

            const chatRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'chat');
            const chatQ = query(chatRef, orderBy('timestamp', 'desc'), limit(20));
            onSnapshot(chatQ, (snapshot) => {
                const log = document.getElementById('chat-log');
                const msgs = [];
                snapshot.forEach(doc => msgs.push(doc.data()));
                msgs.reverse();
                log.innerHTML = '';
                msgs.forEach(m => {
                    const el = document.createElement('div');
                    el.innerHTML = `<span style="color:#0f0">[${m.user.substr(0,8)}]</span>: ${m.text}`;
                    log.appendChild(el);
                    if(m.text.trim() === '/home' && m.user === userDisplayName) teleportHome();
                });
                log.scrollTop = log.scrollHeight;
            });
            window.addEventListener('beforeunload', () => { if (currentUser) deleteDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'players', userId)); });
        }

        let lastNetworkUpdate = 0;
        function updateNetworkLoop() {
            if (!currentUser || !running) return;
            const now = Date.now();
            if (now - lastNetworkUpdate > 200) {
                lastNetworkUpdate = now;
                setDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'players', userId), {
                    x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z, ry: playerGroup.rotation.y,
                    name: userDisplayName, skin: activeSkin, moving: Math.hypot(vel.x || 0, vel.z || 0) > 0.1, lastSeen: serverTimestamp()
                }, { merge: true });
            }
        }

        function createRemotePlayer(pid, data) {
            const group = new THREE.Group();
            let model;
            const skinFile = SKINS.find(s => s.id === data.skin)?.file || 'RobotExpressive.glb';
            const loadUrl = (skinFile === 'RobotExpressive.glb') ? 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/models/gltf/RobotExpressive/RobotExpressive.glb' : `./models/${skinFile}`;

            new THREE.GLTFLoader().load(loadUrl, (gltf) => {
                model = gltf.scene; model.position.y = -1.6; model.scale.set(0.4, 0.4, 0.4);
                group.add(model);
                const pMixer = new THREE.AnimationMixer(model);
                const pActions = {};
                gltf.animations.forEach(clip => { pActions[clip.name] = pMixer.clipAction(clip); });
                if(pActions['Idle']) pActions['Idle'].play();
                
                // If already added simplified model, remove it
                if(otherPlayers[pid] && otherPlayers[pid].temp) {
                    scene.remove(otherPlayers[pid].group);
                    otherPlayers[pid].group = group;
                    otherPlayers[pid].model = model;
                    otherPlayers[pid].mixer = pMixer;
                    otherPlayers[pid].actions = pActions;
                    otherPlayers[pid].temp = false;
                    scene.add(group);
                    // Re-add name tag
                    const nameTag = makeTextSprite(data.name || pid.substr(0, 8));
                    nameTag.position.y = 0.5; group.add(nameTag);
                    otherPlayers[pid].nameTag = nameTag;
                    group.position.set(data.x, data.y, data.z);
                }
            }, undefined, () => {
                 // Fallback
                 const m = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.6, 0.6), new THREE.MeshLambertMaterial({color: 0x00ff00}));
                 m.position.y = -0.8; group.add(m);
            });

            // Initial temp placeholder
            if(!model) {
                 const m = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.6, 0.6), new THREE.MeshLambertMaterial({color: 0x888888}));
                 m.position.y = -0.8; group.add(m);
                 const nameTag = makeTextSprite(data.name || pid.substr(0, 8));
                 nameTag.position.y = 0.5; group.add(nameTag);
                 scene.add(group);
                 otherPlayers[pid] = { group, nameTag, targetPos: new THREE.Vector3(data.x, data.y, data.z), targetRot: data.ry, temp: true };
                 group.position.set(data.x, data.y, data.z);
            }
        }

        function updateRemotePlayer(pid, data) {
            const p = otherPlayers[pid];
            if (!p) return;
            p.targetPos.set(data.x, data.y, data.z);
            p.targetRot = data.ry;
            if (p.mixer) {
                const isMoving = data.moving || p.targetPos.distanceTo(p.group.position) > 0.05;
                const nextAction = isMoving ? 'Walking' : 'Idle';
                if (p.currentAction !== nextAction) {
                    if (p.actions[p.currentAction]) p.actions[p.currentAction].fadeOut(0.2);
                    if (p.actions[nextAction]) p.actions[nextAction].reset().fadeIn(0.2).play();
                    p.currentAction = nextAction;
                }
            }
        }

        function removeRemotePlayer(pid) {
            if (otherPlayers[pid]) { scene.remove(otherPlayers[pid].group); delete otherPlayers[pid]; }
        }

        function updateRemotePlayersVisuals(dt) {
            for (let pid in otherPlayers) {
                const p = otherPlayers[pid];
                p.group.position.lerp(p.targetPos, 10 * dt);
                p.group.rotation.y = THREE.MathUtils.lerp(p.group.rotation.y, p.targetRot, 10 * dt);
                if (p.mixer) p.mixer.update(dt);
            }
        }

        function broadcastAction(type, data) { 
            if (!currentUser) return;
            if (type === 'PLACE' || type === 'BREAK') {
                addDoc(collection(db, 'artifacts', APP_ID, 'public', 'data', 'world_changes'), {
                    ...data, author: userId, timestamp: serverTimestamp(), action: type
                });
            } else if (type === 'CHAT') {
                addDoc(collection(db, 'artifacts', APP_ID, 'public', 'data', 'chat'), {
                    user: userDisplayName, text: data.text, timestamp: serverTimestamp()
                });
            }
        }

        function hash(x, y, z) { let h = (x * 374761393) ^ (y * 668265263) ^ (z * 1274126177); return (h ^ (h >>> 16)) >>> 0; }

        function savePlayerData() {
            if(!currentUser) return;
            const data = { 
                coins: playerCoins, 
                inventory: playerInventory, 
                tool: activeTool,
                claims: myClaims,
                skin: activeSkin,
                hotbar: hotbarSlots
            };
            setDoc(doc(db, 'artifacts', APP_ID, 'public', 'users', userId), data, { merge: true });
        }

        async function createAtlas() {
            const S = 32; 
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            const uniqueFiles = [...new Set(Object.values(BLOCKS).flatMap(b => b.files || []))];
            ATLAS_COLS = 8; ATLAS_ROWS = Math.max(1, Math.ceil(uniqueFiles.length / ATLAS_COLS));
            canvas.width = S * ATLAS_COLS; canvas.height = S * ATLAS_ROWS;
            const fileToId = {};
            for (let i = 0; i < uniqueFiles.length; i++) {
                await new Promise(r => {
                    const img = new Image(); img.crossOrigin = "Anonymous";
                    img.onload = () => { ctx.drawImage(img, (i%ATLAS_COLS)*S, Math.floor(i/ATLAS_COLS)*S, S, S); r(); };
                    img.onerror = () => { ctx.fillStyle = '#F0F'; ctx.fillRect((i%ATLAS_COLS)*S, Math.floor(i/ATLAS_COLS)*S, S, S); r(); };
                    img.src = new URL(`./assets/${uniqueFiles[i]}`, window.location.href).href;
                });
                fileToId[uniqueFiles[i]] = i;
            }
            Object.values(BLOCKS).forEach(b => { if(b.files) b.tiles = b.files.map(f => fileToId[f]); });
            const tex = new THREE.CanvasTexture(canvas); tex.magFilter = THREE.NearestFilter; return tex;
        }

        function getBlock(x, y, z) {
            const k = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if(world[k] !== undefined) return world[k];
            if(y < 0) return 0;
            if(y === 0) return 9;
            const h = Math.floor(10 + Math.sin(x*0.05 + z*0.03)*4 + Math.cos(x*0.03 - z*0.05)*3);
            
            // Ore Generation
            if (y < h - 3) {
                 const rand = hash(x, y, z);
                 // Diamond Block (Super Rare)
                 if (rand % 2000 === 0) return 54; 
                 // Diamond Ore
                 if (rand % 1000 < 5) return 15;
                 // Gold Ore
                 if (rand % 500 < 10) return 14;
                 // Iron Ore
                 if (rand % 200 < 15) return 13;
                 // Coal Ore
                 if (rand % 100 < 20) return 12;
                 return 3; // Stone
            }

            if (y > h) return 0;
            if (y === h) return (h < 7) ? 6 : 1;
            return (y > h - 3) ? 2 : 3;
        }

        function buildChunk(cx, cz) {
            const pos=[], norm=[], uv=[], color=[], idx=[]; let count = 0;
            for(let x=0; x<CHUNK_SIZE; x++) for(let z=0; z<CHUNK_SIZE; z++) for(let y=0; y<32; y++) {
                const wx = cx*CHUNK_SIZE+x, wz = cz*CHUNK_SIZE+z;
                const type = getBlock(wx, y, wz);
                if(type === 0 || !BLOCKS[type]) continue;
                const isTorch = BLOCKS[type].isTorch;
                const faces = [{n:[1,0,0],v:[1,0,0,1,1,0,1,1,1,1,0,1],ao:0.8},{n:[-1,0,0],v:[0,0,1,0,1,1,0,1,0,0,0,0],ao:0.8},{n:[0,1,0],v:[0,1,1,1,1,1,1,1,0,0,1,0],ao:1.0},{n:[0,-1,0],v:[0,0,0,1,0,0,1,0,1,0,0,1],ao:0.5},{n:[0,0,1],v:[1,0,1,1,1,1,0,1,1,0,0,1],ao:0.9},{n:[0,0,-1],v:[0,0,0,0,1,0,1,1,0,1,0,0],ao:0.9}];
                faces.forEach((f, fi) => {
                    const nType = getBlock(wx+f.n[0], y+f.n[1], wz+f.n[2]);
                    if (!isTorch) if(nType !== 0 && (!BLOCKS[nType].transparent || nType === type)) return;
                    for(let i=0; i<4; i++) {
                        let vx = f.v[i*3], vy = f.v[i*3+1], vz = f.v[i*3+2];
                        if(isTorch) { vx = 0.4375 + vx*0.125; vy = vy*0.625; vz = 0.4375 + vz*0.125; }
                        pos.push(wx+vx, y+vy, wz+vz); norm.push(...f.n); 
                        if(isTorch) color.push(1.5, 1.3, 1.0); else color.push(f.ao, f.ao, f.ao);
                    }
                    const tIdx = BLOCKS[type].tiles[fi];
                    uv.push((tIdx%ATLAS_COLS)/ATLAS_COLS, 1-(Math.floor(tIdx/ATLAS_COLS)+1)/ATLAS_ROWS, (tIdx%ATLAS_COLS)/ATLAS_COLS, 1-Math.floor(tIdx/ATLAS_COLS)/ATLAS_ROWS, (tIdx%ATLAS_COLS+1)/ATLAS_COLS, 1-Math.floor(tIdx/ATLAS_COLS)/ATLAS_ROWS, (tIdx%ATLAS_COLS+1)/ATLAS_COLS, 1-(Math.floor(tIdx/ATLAS_COLS)+1)/ATLAS_ROWS);
                    idx.push(count, count+1, count+2, count, count+2, count+3); count += 4;
                });
            }
            if(count === 0) return null;
            const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); geo.setAttribute('normal', new THREE.Float32BufferAttribute(norm, 3)); geo.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2)); geo.setAttribute('color', new THREE.Float32BufferAttribute(color, 3)); geo.setIndex(idx);
            return new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ map: atlas, vertexColors: true, transparent: true, alphaTest: 0.1 }));
        }

        function refreshChunk(wx, wz) {
            const cx = Math.floor(wx/CHUNK_SIZE), cz = Math.floor(wz/CHUNK_SIZE), k = `${cx},${cz}`;
            if(chunkMeshes[k]) { scene.remove(chunkMeshes[k]); clickables = clickables.filter(c => c !== chunkMeshes[k]); delete chunkMeshes[k]; }
            const m = buildChunk(cx, cz); if(m) { scene.add(m); clickables.push(m); chunkMeshes[k] = m; }
        }

        function checkClaimPermission(x, z, action) {
            const cx = Math.floor(x/16), cz = Math.floor(z/16);
            const owner = landClaims[`${cx},${cz}`];
            if (owner && owner !== userId) {
                // Show floating text warning
                const warn = makeTextSprite("LAND CLAIMED BY " + owner.substr(0,8));
                warn.position.set(x, playerGroup.position.y, z);
                scene.add(warn);
                setTimeout(() => scene.remove(warn), 2000);
                return false;
            }
            return true;
        }

        function addToInventory(id, amount=1) {
            // Check for existing stack
            for(let i=0; i<30; i++) {
                if(playerInventory[i].id === id) { playerInventory[i].count += amount; savePlayerData(); updateUI(); return; }
            }
            // Find empty slot
            for(let i=0; i<30; i++) {
                if(playerInventory[i].count === 0) { playerInventory[i] = { id, count: amount }; savePlayerData(); updateUI(); return; }
            }
            // Inventory full warning?
        }

        function removeFromInventory(id) {
            for(let i=0; i<30; i++) {
                if(playerInventory[i].id === id && playerInventory[i].count > 0) {
                    playerInventory[i].count--;
                    if(playerInventory[i].count === 0) playerInventory[i].id = 0;
                    savePlayerData(); updateUI();
                    return true;
                }
            }
            return false;
        }

        function interact(place) {
            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects(clickables);
            if(hits.length > 0) {
                const h = hits[0], n = h.face.normal;
                const bx = Math.floor(h.point.x - n.x*0.05), by = Math.floor(h.point.y - n.y*0.05), bz = Math.floor(h.point.z - n.z*0.05);
                const pbx = Math.floor(h.point.x + n.x*0.05), pby = Math.floor(h.point.y + n.y*0.05), pbz = Math.floor(h.point.z + n.z*0.05);
                
                if(place) {
                    if (!checkClaimPermission(pbx, pbz, 'place')) return false;
                    const id = hotbarSlots[activeHotbarIndex];
                    if(id === 0 || getBlock(pbx, pby, pbz) !== 0) return false;
                    
                    // Inventory Check
                    const hasItem = playerInventory.find(s => s.id === id && s.count > 0);
                    if (!hasItem) return false;

                    const px = playerGroup.position.x, py = playerGroup.position.y, pz = playerGroup.position.z;
                    if(px + PLAYER_RADIUS > pbx && px - PLAYER_RADIUS < pbx + 1 && pz + PLAYER_RADIUS > pbz && pz - PLAYER_RADIUS < pbz + 1 && py > pby && py - PLAYER_HEIGHT < pby + 1) return false;
                    
                    if (id === CLAIM_BLOCK_ID) {
                        if (myClaims >= 10) { alert('Max claims reached!'); return false; }
                        myClaims++;
                        // Land claim logic handles in snapshot
                    }

                    removeFromInventory(id);
                    const k = `${pbx},${pby},${pbz}`; world[k] = id; 
                    if(id === 10) activeTorches.push({x:pbx, y:pby, z:pbz, k});
                    refreshChunk(pbx, pbz);
                    broadcastAction('PLACE', { x: pbx, y: pby, z: pbz, id });
                    return true;
                } else {
                    if (!checkClaimPermission(bx, bz, 'break')) return false;
                    const type = getBlock(bx, by, bz);
                    if(type === 0 || BLOCKS[type]?.indestructible) return false;
                    
                    // Time to break check handled by UI progress
                    const k = `${bx},${by},${bz}`;
                    world[k] = 0; 
                    if(type === 10) activeTorches = activeTorches.filter(t => t.k !== k);
                    if (type === CLAIM_BLOCK_ID) myClaims--;

                    addToInventory(type, 1);
                    
                    refreshChunk(bx, bz);
                    broadcastAction('BREAK', { x: bx, y: by, z: bz, prevId: type });
                    return true;
                }
            }
            return false;
        }

        function startMining() {
            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects(clickables);
            if(hits.length === 0) return;
            const h = hits[0], n = h.face.normal;
            const bx = Math.floor(h.point.x - n.x*0.05), by = Math.floor(h.point.y - n.y*0.05), bz = Math.floor(h.point.z - n.z*0.05);
            const type = getBlock(bx, by, bz);
            if(type === 0 || BLOCKS[type]?.indestructible) return;

            const baseHardness = BLOCKS[type].hardness || 1.0;
            const toolSpeed = activeTool.speed || 1.0;
            const breakTime = Math.max(100, (baseHardness / toolSpeed) * 1000);
            
            touchState.mineStart = Date.now();
            const progress = document.getElementById('break-progress');
            progress.style.transition = `transform ${breakTime}ms linear`;
            progress.style.transform = 'translate(-50%, -50%) scale(1)';

            touchState.timer = setTimeout(() => {
                if(interact(false)) {
                    progress.style.transition = 'none';
                    progress.style.transform = 'translate(-50%, -50%) scale(0)';
                }
            }, breakTime);
        }

        function stopMining() {
            if (touchState.timer) clearTimeout(touchState.timer);
            const progress = document.getElementById('break-progress');
            progress.style.transition = 'none';
            progress.style.transform = 'translate(-50%, -50%) scale(0)';
        }

        function toggleInventory() {
            const overlay = document.getElementById('inventory-overlay');
            const isOpening = overlay.style.display !== 'flex';
            overlay.style.display = isOpening ? 'flex' : 'none';
            if(isOpening) {
                const grid = document.getElementById('inventory-grid'); grid.innerHTML = '';
                playerInventory.forEach((slot, idx) => {
                    const item = document.createElement('div'); item.className = 'slot';
                    if(slot.count > 0 && BLOCKS[slot.id]) {
                        const c = document.createElement('canvas'); c.width=32; c.height=32;
                        const t = BLOCKS[slot.id].tiles[4]; const ctx = c.getContext('2d');
                        ctx.drawImage(atlas.image, (t % ATLAS_COLS) * 32, Math.floor(t / ATLAS_COLS) * 32, 32, 32, 0, 0, 32, 32);
                        item.appendChild(c);
                        const badge = document.createElement('div'); badge.className = 'count-badge'; badge.innerText = slot.count; item.appendChild(badge);
                    }
                    item.onclick = () => { 
                        if (deleteMode) {
                            if (slot.count > 0) { slot.count = 0; slot.id = 0; savePlayerData(); toggleInventory(); toggleInventory(); }
                        } else if (slot.count > 0) {
                            hotbarSlots[activeHotbarIndex] = slot.id; 
                            updateUI(); 
                            toggleInventory(); 
                        }
                    };
                    grid.appendChild(item);
                });
                if(document.pointerLockElement) document.exitPointerLock();
            } else if(!isTouch && !paused) document.body.requestPointerLock();
        }

        function openShop() {
            const overlay = document.getElementById('shop-overlay'); overlay.style.display = 'flex';
            if(document.pointerLockElement) document.exitPointerLock();
            loadShopTab('blocks');
        }

        function loadShopTab(tab) {
            const container = document.getElementById('shop-items-container'); container.innerHTML = '';
            document.querySelectorAll('.shop-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
            
            if (tab === 'blocks') {
                Object.entries(BLOCKS).forEach(([k, b]) => {
                    if (b.indestructible || !b.price) return;
                    const div = document.createElement('div'); div.className = 'shop-item';
                    const name = document.createElement('div'); name.innerText = b.name; name.style.fontSize = '8px'; name.style.color = '#fff';
                    const price = document.createElement('div'); price.className = 'shop-price'; price.innerText = `$${b.price}`;
                    
                    const c = document.createElement('canvas'); c.width=32; c.height=32;
                    const t = b.tiles[4]; const ctx = c.getContext('2d');
                    ctx.drawImage(atlas.image, (t % ATLAS_COLS) * 32, Math.floor(t / ATLAS_COLS) * 32, 32, 32, 0, 0, 32, 32);

                    const sellBtn = document.createElement('div'); sellBtn.className = 'sell-btn'; sellBtn.innerText = 'SELL';
                    sellBtn.onclick = (e) => { e.stopPropagation(); sellBlock(parseInt(k), b.price); };

                    div.onclick = () => buyBlock(parseInt(k), b.price);
                    div.append(name, c, price, sellBtn);
                    container.appendChild(div);
                });
            } else if (tab === 'tools') {
                TOOLS.forEach(tool => {
                    const div = document.createElement('div'); div.className = 'shop-item';
                    div.innerHTML = `<div style="font-size:8px;color:#fff">${tool.name}</div><div class="shop-price">$${tool.cost}</div>`;
                    div.onclick = () => {
                        if (playerCoins >= tool.cost) {
                            playerCoins -= tool.cost; activeTool = tool; savePlayerData(); updateUI();
                            alert(`Bought ${tool.name}!`);
                        } else alert("Not enough coins!");
                    };
                    container.appendChild(div);
                });
            } else if (tab === 'skins') {
                SKINS.forEach(skin => {
                    const div = document.createElement('div'); div.className = 'shop-item';
                    div.innerHTML = `<div style="font-size:8px;color:#fff">${skin.name}</div><div class="shop-price">$${skin.cost}</div>`;
                    div.onclick = () => {
                        if (skin.id === activeSkin) { alert("Already equipped"); return; }
                        if (playerCoins >= skin.cost) {
                            if (skin.cost > 0) playerCoins -= skin.cost; 
                            activeSkin = skin.id; savePlayerData(); 
                            // Reload local model visual
                            if(externalModel) { 
                                scene.remove(playerGroup); 
                                // Simplified: Just need to reload page to see own skin effect correctly or restructure init. 
                                // For now, simple alert.
                                alert(`Equipped ${skin.name}. Respawn to see effect.`);
                            }
                        } else alert("Not enough coins!");
                    };
                    container.appendChild(div);
                });
            }
        }

        function buyBlock(id, price) {
            if (playerCoins >= price) {
                playerCoins -= price;
                addToInventory(id, 1);
                updateUI();
            } else alert("Not enough coins!");
        }

        function sellBlock(id, price) {
            if (removeFromInventory(id)) {
                playerCoins += price;
                updateUI();
                openShop(); // refresh
            } else alert("You don't have this block!");
        }

        function teleportHome() {
            // Find a claim owned by user
            for (let k in landClaims) {
                if (landClaims[k] === userId) {
                    const parts = k.split(',');
                    const x = parseInt(parts[0]) * 16 + 8;
                    const z = parseInt(parts[1]) * 16 + 8;
                    playerGroup.position.set(x, 40, z);
                    vel.y = 0;
                    return;
                }
            }
            addDoc(collection(db, 'artifacts', APP_ID, 'public', 'data', 'chat'), {
                user: "SYSTEM", text: "No land claimed!", timestamp: serverTimestamp()
            });
        }

        function updateUI() {
            const slots = document.getElementById('hotbar-slots'); slots.innerHTML = '';
            hotbarSlots.forEach((id, i) => {
                const s = document.createElement('div'); s.className = 'slot' + (i === activeHotbarIndex ? ' active' : '');
                
                // Check if we actually have this item in inventory to display count
                const invItem = playerInventory.find(item => item.id === id && item.count > 0);
                
                if(id > 0 && invItem) { 
                    const c = document.createElement('canvas'); c.width=24; c.height=24;
                    const t = BLOCKS[id].tiles[4]; 
                    const ctx = c.getContext('2d'); 
                    ctx.drawImage(atlas.image, (t % ATLAS_COLS) * 32, Math.floor(t / ATLAS_COLS) * 32, 32, 32, 0, 0, 24, 24); 
                    s.appendChild(c);
                    const b = document.createElement('div'); b.className = 'count-badge'; b.innerText = invItem.count; s.appendChild(b);
                } else if (id > 0) {
                     // In hotbar but 0 count
                     hotbarSlots[i] = 0; 
                }
                s.onclick = (e) => { e.stopPropagation(); activeHotbarIndex = i; updateUI(); }; slots.appendChild(s);
            });
            document.getElementById('coin-count').innerText = playerCoins;
        }

        function setupInput() {
            document.getElementById('inv-btn').onclick = (e) => { e.stopPropagation(); toggleInventory(); };
            document.getElementById('close-inv').onclick = () => toggleInventory();
            document.getElementById('shop-btn').onclick = (e) => { e.stopPropagation(); openShop(); };
            document.getElementById('close-shop').onclick = () => { document.getElementById('shop-overlay').style.display = 'none'; if(!isTouch) document.body.requestPointerLock(); };
            document.getElementById('chat-toggle-btn').onclick = (e) => { e.stopPropagation(); document.getElementById('chat-container').style.display = 'flex'; document.getElementById('chat-input').focus(); document.exitPointerLock(); };
            document.getElementById('chat-send-btn').onclick = (e) => { e.stopPropagation(); const t = document.getElementById('chat-input'); if(t.value) { broadcastAction('CHAT', {text: t.value}); t.value=''; }};
            document.getElementById('delete-toggle').onclick = () => { deleteMode = !deleteMode; document.getElementById('delete-toggle').classList.toggle('active', deleteMode); document.getElementById('delete-toggle').innerText = deleteMode ? "DELETE MODE: ON" : "DELETE MODE: OFF"; };
            
            document.querySelectorAll('.shop-tab').forEach(t => t.onclick = () => loadShopTab(t.dataset.tab));

            const pBtn = document.getElementById('pause-btn'), camBtn = document.getElementById('cam-btn'), fsBtn = document.getElementById('fs-btn'), pMenu = document.getElementById('pause-menu');
            camBtn.onclick = (e) => { e.stopPropagation(); povMode = (povMode + 1) % 3; if (povMode === 0) { camera.position.set(0,0,0); camera.rotation.y = 0; if(externalModel) externalModel.visible=false; } else { camera.position.set(0, 0.5, povMode===1?4:-4); camera.rotation.y = povMode===1?0:Math.PI; if(externalModel) externalModel.visible=true; }};
            fsBtn.onclick = (e) => { e.stopPropagation(); if (!document.fullscreenElement) document.documentElement.requestFullscreen().then(() => fsBtn.innerText = "EXIT"); else document.exitFullscreen().then(() => fsBtn.innerText = "FULL"); };
            pBtn.onclick = (e) => { e.stopPropagation(); paused = true; pMenu.style.display = 'flex'; document.exitPointerLock(); };
            document.getElementById('resume-btn').onclick = () => { paused = false; pMenu.style.display = 'none'; if(!isTouch) document.body.requestPointerLock(); };
            document.getElementById('quit-btn').onclick = () => { savePlayerData(); location.reload(); };

            if(isTouch) {
                const zone = document.getElementById('joy-zone'), nub = document.getElementById('joy-nub');
                document.addEventListener('touchstart', e => {
                    if (!running || paused) return;
                    for(let t of e.changedTouches) {
                        const r = zone.getBoundingClientRect();
                        if (t.target.closest('#hotbar-container') || t.target.closest('.corner-btn') || t.target.closest('#inventory-overlay') || t.target.closest('#chat-container') || t.target.closest('#shop-overlay')) continue;
                        if(Math.hypot(t.clientX-(r.left+r.width/2), t.clientY-(r.top+r.height/2)) < 60) { joy.id = t.identifier; joy.sx = t.clientX; joy.sy = t.clientY; }
                        else if(t.target.closest('#jump-btn')) { if(Date.now()-lastJumpTime<300){isFlying=!isFlying; vel.y=0;} else if(!isFlying && onGround) vel.y=9; lastJumpTime=Date.now(); }
                        else if(t.target.closest('#up-btn')) { isTouchingUp = true; }
                        else if(t.target.closest('#down-btn')) { isTouchingDown = true; }
                        else if(touchState.id === null) {
                            touchState.id = t.identifier; touchState.lx = t.clientX; touchState.ly = t.clientY; touchState.sx = t.clientX; touchState.sy = t.clientY; 
                            touchState.startTime = Date.now(); touchState.moved = false;
                            startMining();
                        }
                    }
                });
                document.addEventListener('touchmove', e => {
                    if(!running) return;
                    for(let t of e.changedTouches) {
                        if(t.identifier === joy.id) {
                            const dx = t.clientX - joy.sx, dy = t.clientY - joy.sy, d = Math.min(45, Math.hypot(dx,dy)), angle = Math.atan2(dy, dx);
                            joy.x = (Math.cos(angle) * d) / 45; joy.y = (Math.sin(angle) * d) / 45;
                            nub.style.transform = `translate(${Math.cos(angle)*d - 20}px,${Math.sin(angle)*d - 20}px)`;
                        } else if(t.identifier === touchState.id) {
                            if(Math.hypot(t.clientX - touchState.sx, t.clientY - touchState.sy) > MOVE_THRESHOLD) {
                                touchState.moved = true; 
                                stopMining();
                            }
                            playerGroup.rotation.y -= (t.clientX - touchState.lx) * 0.008;
                            cameraPivot.rotation.x = Math.max(-1.5, Math.min(1.5, cameraPivot.rotation.x - (t.clientY - touchState.ly) * 0.008));
                            touchState.lx = t.clientX; touchState.ly = t.clientY;
                        }
                    }
                });
                document.addEventListener('touchend', e => {
                    if(!running) return;
                    for(let t of e.changedTouches) {
                        if(t.identifier === joy.id) { joy.id=null; joy.x=0; joy.y=0; nub.style.transform='translate(-50%,-50%)'; }
                        else if(t.target.closest('#up-btn')) { isTouchingUp = false; }
                        else if(t.target.closest('#down-btn')) { isTouchingDown = false; }
                        else if(t.identifier === touchState.id) { 
                            stopMining();
                            if(!touchState.moved && (Date.now() - touchState.startTime) < 200) interact(true); 
                            touchState.id = null; 
                        }
                    }
                });
            } else {
                window.onkeydown = e => { if (!running || document.activeElement.tagName === 'INPUT') return; keys[e.key.toLowerCase()] = 1; if(e.key===' ') { if(Date.now()-lastJumpTime<300){isFlying=!isFlying; vel.y=0;} else if(!isFlying && onGround) vel.y=9; lastJumpTime=Date.now(); } if(e.key==='Escape') { paused=!paused; pMenu.style.display=paused?'flex':'none'; }};
                window.onkeyup = e => { if(!running) return; keys[e.key.toLowerCase()] = 0; };
                
                window.onmousedown = e => { 
                    if(!running || paused || document.activeElement.tagName === 'INPUT') return; 
                    if(e.button === 0) startMining();
                    else if(e.button === 2) interact(true);
                };
                window.onmouseup = e => { stopMining(); };
                
                window.onmousemove = e => { if(!running || !document.pointerLockElement) return; playerGroup.rotation.y-=e.movementX*0.002; cameraPivot.rotation.x=Math.max(-1.5, Math.min(1.5, cameraPivot.rotation.x-e.movementY*0.002)); };
            }
        }

        function animate() {
            if(!running) return;
            requestAnimationFrame(animate);
            if(paused) { renderer.render(scene, camera); return; }
            const now = performance.now(), dt = Math.min((now - lastNetworkUpdate) / 1000, 0.1); 
            if(mixer) mixer.update(0.016);
            if(isFlying) { let flyVel = 0; if (keys[' '] || isTouchingUp) flyVel += 1; if (keys['shift'] || isTouchingDown) flyVel -= 1; vel.y = flyVel * 10; } else { vel.y -= 24 * 0.016; }
            const r = playerGroup.rotation.y, speed = isFlying ? 12 : 5.5; 
            let mx=0, mz=0; if(isTouch) { mx=joy.x; mz=joy.y; } else { if(keys.w)mz=-1; if(keys.s)mz=1; if(keys.a)mx=-1; if(keys.d)mx=1; }
            const dx = (Math.sin(r)*mz + Math.cos(r)*mx) * speed, dz = (Math.cos(r)*mz - Math.sin(r)*mx) * speed;
            
            // Basic Physics / Collision
            const ox = playerGroup.position.x; playerGroup.position.x += dx*0.016; 
            if (getBlock(playerGroup.position.x, playerGroup.position.y, playerGroup.position.z) !== 0) playerGroup.position.x = ox;
            const oz = playerGroup.position.z; playerGroup.position.z += dz*0.016;
            if (getBlock(playerGroup.position.x, playerGroup.position.y, playerGroup.position.z) !== 0) playerGroup.position.z = oz;

            playerGroup.position.y += vel.y*0.016;
            if(playerGroup.position.y < -10) playerGroup.position.y = 40; // Void reset
            
            // Simple Ground Check
            if(getBlock(playerGroup.position.x, playerGroup.position.y - PLAYER_HEIGHT, playerGroup.position.z) !== 0) {
                 if(vel.y < 0) { playerGroup.position.y = Math.ceil(playerGroup.position.y - PLAYER_HEIGHT) + PLAYER_HEIGHT; vel.y = 0; onGround = true; }
            } else onGround = false;

            if(mixer) { const hv = Math.hypot(dx, dz); if(hv > 0.5) { if(activeAction!==actions['Walking']) {activeAction?.fadeOut(0.2); activeAction=actions['Walking']; activeAction.reset().fadeIn(0.2).play();} } else { if(activeAction!==actions['Idle']) {activeAction?.fadeOut(0.2); activeAction=actions['Idle']; activeAction.reset().fadeIn(0.2).play();} } }
            
            gameTime += 0.016; const angle = ((gameTime % DAY_LENGTH_SECONDS) / DAY_LENGTH_SECONDS) * Math.PI * 2;
            sunLight.position.set(Math.sin(angle) * 60, Math.cos(angle) * 60, 20);
            const skyColor = Math.cos(angle) > 0 ? new THREE.Color(0x87CEEB) : new THREE.Color(0x0a0a1a);
            scene.background = skyColor; scene.fog.color = skyColor; stars.material.opacity = Math.cos(angle) < 0 ? 1 : 0;
            
            raycaster.setFromCamera({x:0, y:0}, camera); const hit = raycaster.intersectObjects(clickables)[0];
            if(hit) { const n = hit.face.normal; selectionBox.position.set(Math.floor(hit.point.x-n.x*0.1)+0.5, Math.floor(hit.point.y-n.y*0.1)+0.5, Math.floor(hit.point.z-n.z*0.1)+0.5); selectionBox.visible = true; } else selectionBox.visible = false;
            
            updateNetworkLoop(); updateRemotePlayersVisuals(0.016);
            
            // Lazy Chunk Loading
            const px = Math.floor(playerGroup.position.x/CHUNK_SIZE), pz = Math.floor(playerGroup.position.z/CHUNK_SIZE);
            for(let x=px-RENDER_DIST; x<=px+RENDER_DIST; x++) {
                for(let z=pz-RENDER_DIST; z<=pz+RENDER_DIST; z++) {
                    const k = `${x},${z}`; if(!chunkMeshes[k]) refreshChunk(x*CHUNK_SIZE, z*CHUNK_SIZE);
                }
            }
            renderer.render(scene, camera);
        }

        async function startGame(user) {
            currentUser = user; userId = user.uid; userDisplayName = user.displayName || 'Player';
            document.getElementById('user-display-id').innerText = userDisplayName;
            document.getElementById('loading').style.display = 'none';

            // Load User Data
            const docSnap = await getDoc(doc(db, 'artifacts', APP_ID, 'public', 'users', userId));
            if (docSnap.exists()) {
                const d = docSnap.data();
                playerCoins = d.coins || 0;
                playerInventory = d.inventory || playerInventory;
                activeTool = d.tool || activeTool;
                myClaims = d.claims || 0;
                activeSkin = d.skin || 'robot';
                hotbarSlots = d.hotbar || hotbarSlots;
            } else {
                // New player gift: 50 coins
                playerCoins = 50;
            }
            
            initNetwork();
            playerGroup.position.set(0.5, 40, 0.5);
            running = true;
            if(!isTouch) document.body.requestPointerLock();
            else document.querySelectorAll('.ctrl').forEach(e=>e.style.display='flex');
            
            // Load Skin for Self
            const skinFile = SKINS.find(s => s.id === activeSkin)?.file || 'RobotExpressive.glb';
            const loadUrl = (skinFile === 'RobotExpressive.glb') ? 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/models/gltf/RobotExpressive/RobotExpressive.glb' : `./models/${skinFile}`;
            new THREE.GLTFLoader().load(loadUrl, (gltf) => {
                if(externalModel) playerGroup.remove(externalModel);
                externalModel = gltf.scene; externalModel.scale.set(0.4, 0.4, 0.4); externalModel.position.y = -1.6;
                playerGroup.add(externalModel);
                mixer = new THREE.AnimationMixer(externalModel);
                gltf.animations.forEach((clip) => { actions[clip.name] = mixer.clipAction(clip); });
                activeAction = actions['Idle']; activeAction?.play();
            }, undefined, () => {
                 // Fallback if local file fails (likely)
                 new THREE.GLTFLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/models/gltf/RobotExpressive/RobotExpressive.glb', (gltf) => {
                    if(externalModel) playerGroup.remove(externalModel);
                    externalModel = gltf.scene; externalModel.scale.set(0.4, 0.4, 0.4); externalModel.position.y = -1.6;
                    playerGroup.add(externalModel);
                    mixer = new THREE.AnimationMixer(externalModel);
                    gltf.animations.forEach((clip) => { actions[clip.name] = mixer.clipAction(clip); });
                    activeAction = actions['Idle']; activeAction?.play();
                 });
            });

            updateUI();
            animate();
        }

        async function init() {
            atlas = await createAtlas();
            scene = new THREE.Scene(); scene.fog = new THREE.Fog(0x87CEEB, 15, 45);
            playerGroup = new THREE.Group(); scene.add(playerGroup);
            cameraPivot = new THREE.Group(); playerGroup.add(cameraPivot);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100); cameraPivot.add(camera);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
            scene.add(ambientLight = new THREE.AmbientLight(0xffffff, 0.6)); scene.add(sunLight = new THREE.DirectionalLight(0xffffff, 0.8));
            raycaster = new THREE.Raycaster(); selectionBox = new THREE.Mesh(new THREE.BoxGeometry(1.01, 1.01, 1.01), new THREE.MeshBasicMaterial({ color: 0, wireframe: true, transparent: true, opacity: 0.4 }));
            scene.add(selectionBox); 
            
            clouds = new THREE.Mesh(new THREE.BoxGeometry(100, 2, 100), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })); clouds.position.y = 45; scene.add(clouds);
            const starGeo = new THREE.BufferGeometry(), starPos = []; for(let i=0; i<1500; i++) starPos.push((Math.random()-0.5)*100, Math.random()*50+10, (Math.random()-0.5)*100);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3)); stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0 })); scene.add(stars); 
            setupInput();
            
            document.getElementById('loading-text').innerText = 'CHECKING AUTH...';
            setPersistence(auth, browserLocalPersistence).then(() => {
                onAuthStateChanged(auth, (user) => {
                    if (user) startGame(user);
                    else { document.getElementById('loading-text').innerText = 'READY TO CONNECT'; document.getElementById('start-btn').style.display = 'block'; }
                });
            });
            document.getElementById('start-btn').onclick = async () => { try { await signInWithPopup(auth, new GoogleAuthProvider()); } catch (e) { console.error(e); } };
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }
        let last = performance.now(); init();
    </script>
</body>
</html>

