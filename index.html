<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxel Pocket - Multiplayer Edition Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body { margin: 0; overflow: hidden; background: #000; touch-action: none; user-select: none; font-family: 'Press Start 2P', cursive; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center;
        }
        #crosshair::before { content: ''; position: absolute; width: 16px; height: 2px; background: rgba(255,255,255,0.8); mix-blend-mode: difference; }
        #crosshair::after { content: ''; position: absolute; width: 2px; height: 16px; background: rgba(255,255,255,0.8); mix-blend-mode: difference; }

        #break-progress {
            position: absolute; top: 50%; left: 50%; width: 44px; height: 44px;
            border: 4px solid rgba(0,0,0,0.5); border-top-color: #fff; border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 10; transition: transform 0.1s linear;
        }

        .corner-btn {
            position: absolute; top: 10px; width: 40px; height: 40px;
            background: rgba(0,0,0,0.6); border: 2px solid #fff; color: #fff;
            display: flex; align-items: center; justify-content: center;
            font-size: 8px; cursor: pointer; pointer-events: auto;
            box-shadow: 0 4px 0 rgba(0,0,0,0.4); z-index: 100;
        }
        #pause-btn { left: 10px; }
        #chat-toggle-btn { left: 60px; }
        #fs-btn { right: 60px; } 
        #cam-btn { right: 10px; }
        .corner-btn:active { transform: translateY(2px); box-shadow: none; }

        #hotbar-container {
            position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; background: rgba(0,0,0,0.5); padding: 4px; border: 4px solid #111; pointer-events: auto;
            max-width: 95vw;
        }
        .slot {
            width: 40px; height: 40px; border: 3px solid #555; background: #8B8B8B;
            display: flex; justify-content: center; align-items: center; cursor: pointer; position: relative;
            box-shadow: inset 2px 2px #AAA, inset -2px -2px #333; flex-shrink: 0;
        }
        .slot.active { border-color: #FFF; background: #AAA; z-index: 2; transform: scale(1.1); box-shadow: 0 0 12px white; }
        .slot canvas { width: 30px; height: 30px; image-rendering: pixelated; pointer-events: none; }
        
        #inv-btn {
            width: 40px; height: 40px; background: #8B8B8B; border: 3px solid #111; color: #fff;
            display: flex; align-items: center; justify-content: center; font-size: 8px;
            margin-right: 4px; cursor: pointer; text-shadow: 1px 1px #000;
            box-shadow: inset 2px 2px #AAA, inset -2px -2px #333; flex-shrink: 0;
        }

        .ctrl { position: absolute; pointer-events: auto; z-index: 50; display: none; }
        #joy-zone { bottom: 30px; left: 30px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; }
        #joy-nub { position: absolute; top: 50%; left: 50%; width: 44px; height: 44px; background: #fff; border-radius: 50%; transform: translate(-50%, -50%); opacity: 0.5; pointer-events: none; }
        
        #flight-controls {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; gap: 12px; align-items: center;
        }
        .action-btn {
            width: 54px; height: 54px; border-radius: 50%;
            background: rgba(0,0,0,0.4); border: 2px solid rgba(255,255,255,0.5);
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px);
        }
        .action-btn svg { width: 28px; height: 28px; fill: white; opacity: 0.9; }

        #chat-container {
            position: fixed; top: 65px; left: 10px; width: 280px; height: 200px;
            display: none; flex-direction: column; z-index: 2500; pointer-events: auto;
        }
        #chat-header { background: rgba(0,0,0,0.85); color: #0f0; padding: 6px; font-size: 7px; border-bottom: 2px solid #333; }
        #chat-log { flex-grow: 1; background: rgba(0,0,0,0.7); color: #fff; padding: 8px; font-size: 8px; overflow-y: auto; display: flex; flex-direction: column-reverse; }
        #chat-input-wrapper { display: flex; background: rgba(0,0,0,0.9); border: 2px solid #555; }
        #chat-input { flex-grow: 1; background: transparent; border: none; color: #fff; padding: 10px; font-family: 'Press Start 2P'; font-size: 8px; outline: none; }
        #chat-send-btn { background: #555; color: #fff; border: none; padding: 0 12px; cursor: pointer; font-family: 'Press Start 2P'; font-size: 8px; }

        #inventory-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; pointer-events: auto; }
        #inventory-grid { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; background: #8B8B8B; padding: 20px; border: 4px solid #111; max-height: 80vh; overflow-y: auto; }
        
        #pause-menu { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000; pointer-events: auto; }
        .menu-card { background: #8B8B8B; padding: 25px; border: 5px solid #000; display: flex; flex-direction: column; gap: 12px; width: 220px; }
        .menu-btn { padding: 14px; background: #777; color: #fff; border: 3px solid #000; font-family: 'Press Start 2P'; font-size: 10px; cursor: pointer; text-align: center; }
        .menu-btn:hover { background: #999; }

        #loading { position: fixed; inset: 0; background: #111; color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #start-btn { padding: 14px 35px; font-family: 'Press Start 2P'; font-size: 14px; cursor: pointer; background: #777; color: #fff; border: 5px solid #000; margin-top: 20px; display: none;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/SkeletonUtils.js"></script>
</head>
<body>
    <div id="loading">
        <h1 style="font-size: 24px; text-shadow: 4px 4px #555; text-align: center; margin-bottom: 20px;">VOXEL POCKET<br><span style="font-size: 10px; color: #ffd700;">MULTIPLAYER PRO</span></h1>
        <p id="loading-text" style="font-size: 8px; color: #aaa; margin-top: 10px;">GENERATING TERRAIN...</p>
        <button id="start-btn">ENTER WORLD (GOOGLE LOGIN)</button>
    </div>

    <div id="ui">
        <div id="crosshair"></div>
        <div id="break-progress"></div>
        
        <div id="pause-btn" class="corner-btn ctrl">||</div>
        <div id="chat-toggle-btn" class="corner-btn ctrl">MSG</div>
        <div id="fs-btn" class="corner-btn ctrl">FULL</div>
        <div id="cam-btn" class="corner-btn ctrl">POV</div>

        <div id="chat-container">
            <div id="chat-header">ID: <span id="user-display-id">...</span></div>
            <div id="chat-log"></div>
            <div id="chat-input-wrapper">
                <input type="text" id="chat-input" placeholder="..." maxlength="50">
                <button id="chat-send-btn">></button>
            </div>
        </div>

        <div id="hotbar-container">
            <div id="inv-btn">INV</div>
            <div id="hotbar-slots" style="display: flex; gap: 4px;"></div>
        </div>
        <div id="joy-zone" class="ctrl"><div id="joy-nub"></div></div>
        
        <div id="flight-controls" class="ctrl">
            <div id="up-btn" class="action-btn" style="display: none;">
                <svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>
            </div>
            <div id="jump-btn" class="action-btn">
                <svg viewBox="0 0 24 24"><path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/></svg>
            </div>
            <div id="down-btn" class="action-btn" style="display: none;">
                <svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
            </div>
        </div>
    </div>

    <div id="pause-menu">
        <div class="menu-card">
            <div style="text-align: center; margin-bottom: 10px; color: #fff; text-shadow: 2px 2px #000; font-size: 12px;">PAUSED</div>
            <div id="resume-btn" class="menu-btn">RESUME</div>
            <div id="quit-btn" class="menu-btn" style="background: #a33;">QUIT GAME</div>
        </div>
    </div>

    <div id="inventory-overlay">
        <div style="color: white; margin-bottom: 15px; font-size: 12px; letter-spacing: 1px;">CREATIVE INVENTORY</div>
        <div id="inventory-grid"></div>
        <button id="close-inv" class="menu-btn" style="margin-top: 20px; width: 180px;">CLOSE</button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, browserLocalPersistence, setPersistence } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, orderBy, limit, setDoc, doc, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

        // --- Perlin Noise Implementation (Simplified for JS) ---
        const Perlin = new (function() {
            this.p = new Uint8Array(512);
            const permutation = new Uint8Array(256);
            for(let i=0; i<256; i++) permutation[i] = i;
            for(let i=255; i>0; i--) { const r = Math.floor(Math.random()*(i+1)); [permutation[i], permutation[r]] = [permutation[r], permutation[i]]; }
            for(let i=0; i<512; i++) this.p[i] = permutation[i % 256];

            this.fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            this.lerp = (t, a, b) => a + t * (b - a);
            this.grad = (hash, x, y, z) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };

            this.noise = (x, y, z) => {
                const X = Math.floor(x) & 255; const Y = Math.floor(y) & 255; const Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = this.fade(x); const v = this.fade(y); const w = this.fade(z);
                const A = this.p[X]+Y, AA = this.p[A]+Z, AB = this.p[A+1]+Z;
                const B = this.p[X+1]+Y, BA = this.p[B]+Z, BB = this.p[B+1]+Z;
                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x-1, y, z)),
                                     this.lerp(u, this.grad(this.p[AB], x, y-1, z), this.grad(this.p[BB], x-1, y-1, z))),
                               this.lerp(v, this.lerp(u, this.grad(this.p[AA+1], x, y, z-1), this.grad(this.p[BA+1], x-1, y, z-1)),
                                     this.lerp(u, this.grad(this.p[AB+1], x, y-1, z-1), this.grad(this.p[BB+1], x-1, y-1, z-1))));
            };
        })();

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBgQaeWlxecgunDZo8xHBorRVIrZ8K4YJ8",
            authDomain: "pixelbox-bca1b.firebaseapp.com",
            projectId: "pixelbox-bca1b",
            storageBucket: "pixelbox-bca1b.firebasestorage.app",
            messagingSenderId: "709778027442",
            appId: "1:709778027442:web:c2959397d3285e1f24eaab"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const APP_ID = 'pixelbox_pro_v1'; 

        // Game Constants
        const CHUNK_SIZE = 16;
        const CHUNK_HEIGHT = 128; // Increased height for complex terrain
        const RENDER_DIST = 3;
        const PLAYER_HEIGHT = 1.7;
        const PLAYER_RADIUS = 0.35;
        const DAY_LENGTH_SECONDS = 600; 
        const MINE_DELAY = 350; 
        const WATER_LEVEL = 40;

        // State Variables
        let currentUser = null, userId = 'Guest', userDisplayName = 'Guest';
        let otherPlayers = {}; 
        let ATLAS_COLS = 8, ATLAS_ROWS = 8;
        let scene, camera, renderer, raycaster, atlas, sunLight, ambientLight, clouds, stars;
        let playerGroup, cameraPivot, modelLoaded = false, robotModel = null;
        let world = {}, chunkMeshes = {}, clickables = [];
        let vel = new THREE.Vector3(), onGround = false, gameTime = 0, running = false, paused = false;
        let isTouch = 'ontouchstart' in window;
        let activeHotbarIndex = 0;
        let hotbarSlots = [1, 3, 4, 12, 17, 8, 10, 35];
        let selectionBox;
        const keys = {}, joy = { x: 0, y: 0, id: null, sx: 0, sy: 0 };
        const touchState = { id: null, lx: 0, ly: 0, sx: 0, sy: 0, timer: null, moved: false, startTime: 0 };
        let isFlying = false, lastJumpTime = 0, isTouchingDown = false, isTouchingUp = false, povMode = 0, povDist = 4;
        let mixer, actions = {}, activeAction;

        const BLOCKS = {
            1: { name: 'Grass',  files: ['grass_side.png', 'grass_side.png', 'grass_top.png', 'dirt.png', 'grass_side.png', 'grass_side.png'] },
            2: { name: 'Dirt',   files: ['dirt.png', 'dirt.png', 'dirt.png', 'dirt.png', 'dirt.png', 'dirt.png'] },
            3: { name: 'Stone',  files: ['stone.png', 'stone.png', 'stone.png', 'stone.png', 'stone.png', 'stone.png'] },
            4: { name: 'Log',    files: ['log_side.png', 'log_side.png', 'log_top.png', 'log_top.png', 'log_side.png', 'log_side.png'] },
            5: { name: 'Leaves', files: ['leaves.png', 'leaves.png', 'leaves.png', 'leaves.png', 'leaves.png', 'leaves.png'], transparent: true },
            6: { name: 'Sand',   files: ['sand.png', 'sand.png', 'sand.png', 'sand.png', 'sand.png', 'sand.png'] },
            7: { name: 'Planks', files: ['planks.png', 'planks.png', 'planks.png', 'planks.png', 'planks.png', 'planks.png'] },
            8: { name: 'Glass',  files: ['glass.png', 'glass.png', 'glass.png', 'glass.png', 'glass.png', 'glass.png'], transparent: true },
            9: { name: 'Bedrock', files: ['bedrock.png', 'bedrock.png', 'bedrock.png', 'bedrock.png', 'bedrock.png', 'bedrock.png'], indestructible: true },
            10: { name: 'Torch', files: ['torch.png', 'torch.png', 'torch.png', 'torch.png', 'torch.png', 'torch.png'], isTorch: true, transparent: true },
            11: { name: 'Water', files: ['water.png', 'water.png', 'water.png', 'water.png', 'water.png', 'water.png'], transparent: true, isFluid: true, opacity: 0.6 },
            12: { name: 'Coal Ore', files: ['coal_ore.png', 'coal_ore.png', 'coal_ore.png', 'coal_ore.png', 'coal_ore.png', 'coal_ore.png'] },
            17: { name: 'Cobblestone', files: ['cobblestone.png', 'cobblestone.png', 'cobblestone.png', 'cobblestone.png', 'cobblestone.png', 'cobblestone.png'] },
            20: { name: 'Obsidian', files: ['obsidian.png', 'obsidian.png', 'obsidian.png', 'obsidian.png', 'obsidian.png', 'obsidian.png'] },
            35: { name: 'Crafting', files: ['crafting_side.png', 'crafting_side.png', 'crafting_top.png', 'planks.png', 'crafting_side.png', 'crafting_side.png'] },
            37: { name: 'TNT', files: ['tnt_side.png', 'tnt_side.png', 'tnt_top.png', 'tnt_bottom.png', 'tnt_side.png', 'tnt_side.png'] },
            45: { name: 'Ice', files: ['ice.png', 'ice.png', 'ice.png', 'ice.png', 'ice.png', 'ice.png'], transparent: true, opacity: 0.7 }
        };

        function makeTextSprite(message) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 128;
            context.font = "Bold 36px sans-serif";
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillStyle = "rgba(0,0,0,0.4)";
            const textWidth = context.measureText(message).width;
            context.fillRect(256 - textWidth/2 - 10, 45, textWidth + 20, 40);
            context.fillStyle = "white";
            context.fillText(message, 256, 65);
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(2, 0.5, 1);
            return sprite;
        }

        // --- Advanced Procedural Terrain Logic ---
        function getBlock(x, y, z) {
            const k = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if(world[k] !== undefined) return world[k];
            if(y < 0) return 0;
            if(y === 0) return 9; // Bedrock bottom
            if(y > CHUNK_HEIGHT - 2) return 0;

            // Multi-octave Perlin Noise for Height
            const scale = 0.01;
            const mountainScale = 0.02;
            const detailScale = 0.05;

            // Biome Selection Noise
            const biomeNoise = Perlin.noise(x * 0.005, 0, z * 0.005);
            
            let baseHeight = 45;
            let heightAmplitude = 20;

            if (biomeNoise > 0.1) { // Mountains
                baseHeight += Perlin.noise(x * mountainScale, 0, z * mountainScale) * 50;
            } else if (biomeNoise < -0.1) { // Oceans/Lowlands
                baseHeight -= 15;
                heightAmplitude = 10;
            } else { // Plains
                baseHeight += Perlin.noise(x * scale, 0, z * scale) * 15;
            }

            const h = Math.floor(baseHeight + Perlin.noise(x * detailScale, 0, z * detailScale) * 5);

            // 3D Noise for Caves (Verticality)
            const caveNoise = Perlin.noise(x * 0.08, y * 0.08, z * 0.08);
            if (y < h - 2 && caveNoise > 0.45 && y > 5) return 0;

            if (y > h) {
                // Water system
                if (y <= WATER_LEVEL) return 11; // Water
                return 0;
            }

            if (y === h) {
                if (y < WATER_LEVEL + 2) return 6; // Sand near water
                return 1; // Grass
            }
            if (y > h - 3) return 2; // Dirt layer
            
            // Ore Generation
            const oreNoise = Perlin.noise(x * 0.2, y * 0.2, z * 0.2);
            if (y < 20 && oreNoise > 0.6) return 12; // Coal deep down

            return 3; // Stone core
        }

        // --- Network Layer ---
        function initNetwork() {
            const playersRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'players');
            onSnapshot(playersRef, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const pid = change.doc.id;
                    if (pid === userId) return; 
                    if (change.type === "added" || change.type === "modified") {
                        if (!otherPlayers[pid]) createRemotePlayer(pid, data);
                        updateRemotePlayer(pid, data);
                    }
                    if (change.type === "removed") removeRemotePlayer(pid);
                });
            });

            const worldRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'world_changes');
            onSnapshot(query(worldRef, orderBy('timestamp', 'asc')), (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const d = change.doc.data();
                        const key = `${Math.floor(d.x)},${Math.floor(d.y)},${Math.floor(d.z)}`;
                        world[key] = (d.action === 'PLACE') ? d.id : 0;
                        if (running) refreshChunk(d.x, d.z);
                    }
                });
            });

            const chatRef = collection(db, 'artifacts', APP_ID, 'public', 'data', 'chat');
            onSnapshot(query(chatRef, orderBy('timestamp', 'desc'), limit(15)), (snapshot) => {
                const log = document.getElementById('chat-log');
                log.innerHTML = '';
                const msgs = [];
                snapshot.forEach(doc => msgs.push(doc.data()));
                msgs.reverse().forEach(m => {
                    const el = document.createElement('div');
                    el.style.marginBottom = '4px';
                    el.innerHTML = `<span style="color:#0f0">[${m.user}]</span>: ${m.text}`;
                    log.appendChild(el);
                });
                log.scrollTop = log.scrollHeight;
            });
        }

        let lastNet = 0;
        function updateNetworkLoop() {
            if (!currentUser || !running || Date.now() - lastNet < 100) return;
            lastNet = Date.now();
            setDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'players', userId), {
                x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z,
                ry: playerGroup.rotation.y, name: userDisplayName,
                moving: Math.hypot(vel.x, vel.z) > 0.1, lastSeen: serverTimestamp()
            }, { merge: true });
        }

        function createRemotePlayer(pid, data) {
            const group = new THREE.Group();
            let model;
            let pMixer, pActions = {};

            if (modelLoaded && robotModel) {
                model = SkeletonUtils.clone(robotModel);
                model.position.y = -PLAYER_HEIGHT;
                group.add(model);
                pMixer = new THREE.AnimationMixer(model);
                robotModel.animations.forEach(clip => { pActions[clip.name] = pMixer.clipAction(clip); });
                if(pActions['Idle']) pActions['Idle'].play();
            } else {
                model = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.6), new THREE.MeshLambertMaterial({color: 0x00ff00}));
                model.position.y = -0.9;
                group.add(model);
            }

            const nameTag = makeTextSprite(data.name || pid.substr(0,5));
            nameTag.position.y = 0.6;
            group.add(nameTag);

            scene.add(group);
            otherPlayers[pid] = { group, mixer: pMixer, actions: pActions, currentAction: 'Idle', targetPos: new THREE.Vector3(data.x, data.y, data.z), targetRot: data.ry };
        }

        function updateRemotePlayer(pid, data) {
            const p = otherPlayers[pid];
            if (!p) return;
            p.targetPos.set(data.x, data.y, data.z);
            p.targetRot = data.ry;
            if (p.mixer) {
                const nextAction = data.moving ? 'Walking' : 'Idle';
                if (p.currentAction !== nextAction) {
                    if (p.actions[p.currentAction]) p.actions[p.currentAction].fadeOut(0.2);
                    if (p.actions[nextAction]) p.actions[nextAction].reset().fadeIn(0.2).play();
                    p.currentAction = nextAction;
                }
            }
        }

        function removeRemotePlayer(pid) {
            if (otherPlayers[pid]) { scene.remove(otherPlayers[pid].group); delete otherPlayers[pid]; }
        }

        // --- World Rendering ---
        async function createAtlas() {
            const S = 32; const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const files = [...new Set(Object.values(BLOCKS).flatMap(b => b.files || []))];
            ATLAS_COLS = 8; ATLAS_ROWS = Math.ceil(files.length / 8);
            canvas.width = S * ATLAS_COLS; canvas.height = S * ATLAS_ROWS;
            const map = {};
            for(let i=0; i<files.length; i++) {
                await new Promise(r => {
                    const img = new Image(); img.crossOrigin = "anonymous";
                    img.onload = () => { ctx.drawImage(img, (i%8)*S, Math.floor(i/8)*S, S, S); r(); };
                    img.onerror = () => { ctx.fillStyle='magenta'; ctx.fillRect((i%8)*S, Math.floor(i/8)*S, S, S); r(); };
                    img.src = `https://raw.githubusercontent.com/ArielZohar/Voxel-Textures/main/${files[i]}`;
                });
                map[files[i]] = i;
            }
            Object.values(BLOCKS).forEach(b => b.tiles = b.files.map(f => map[f]));
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter; tex.minFilter = THREE.NearestFilter;
            return tex;
        }

        function buildChunk(cx, cz) {
            const pos=[], norm=[], uv=[], color=[], idx=[];
            let count = 0;
            for(let x=0; x<CHUNK_SIZE; x++) {
                for(let z=0; z<CHUNK_SIZE; z++) {
                    for(let y=0; y<CHUNK_HEIGHT; y++) {
                        const wx = cx*CHUNK_SIZE+x, wz = cz*CHUNK_SIZE+z;
                        const type = getBlock(wx, y, wz);
                        if(type === 0) continue;
                        const isTorch = BLOCKS[type]?.isTorch;
                        const faces = [
                            { n:[1,0,0],  v:[1,0,0, 1,1,0, 1,1,1, 1,0,1], ao:0.8 },
                            { n:[-1,0,0], v:[0,0,1, 0,1,1, 0,1,0, 0,0,0], ao:0.8 },
                            { n:[0,1,0],  v:[0,1,1, 1,1,1, 1,1,0, 0,1,0], ao:1.0 },
                            { n:[0,-1,0], v:[0,0,0, 1,0,0, 1,0,1, 0,0,1], ao:0.5 },
                            { n:[0,0,1],  v:[1,0,1, 1,1,1, 0,1,1, 0,0,1], ao:0.9 },
                            { n:[0,0,-1], v:[0,0,0, 0,1,0, 1,1,0, 1,0,0], ao:0.9 }
                        ];
                        faces.forEach((f, fi) => {
                            const nType = getBlock(wx+f.n[0], y+f.n[1], wz+f.n[2]);
                            if (!isTorch && nType !== 0 && (!BLOCKS[nType]?.transparent || nType === type)) return;
                            for(let i=0; i<4; i++) {
                                let vx = f.v[i*3], vy = f.v[i*3+1], vz = f.v[i*3+2];
                                if(isTorch) { vx = 0.43+vx*0.14; vy = vy*0.6; vz = 0.43+vz*0.14; }
                                pos.push(wx+vx, y+vy, wz+vz); norm.push(...f.n); 
                                color.push(f.ao, f.ao, f.ao);
                            }
                            const tIdx = BLOCKS[type].tiles[fi], u = (tIdx % 8)/8, v = 1 - (Math.floor(tIdx/8)+1)/ATLAS_ROWS;
                            uv.push(u, v, u, v+1/ATLAS_ROWS, u+1/8, v+1/ATLAS_ROWS, u+1/8, v);
                            idx.push(count, count+1, count+2, count, count+2, count+3); count += 4;
                        });
                    }
                }
            }
            if(count === 0) return null;
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('normal', new THREE.Float32BufferAttribute(norm, 3));
            geo.setAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(color, 3));
            geo.setIndex(idx);
            return new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ map: atlas, vertexColors: true, transparent: true, alphaTest: 0.1 }));
        }

        function refreshChunk(wx, wz) {
            const cx = Math.floor(wx/CHUNK_SIZE), cz = Math.floor(wz/CHUNK_SIZE);
            const k = `${cx},${cz}`;
            if(chunkMeshes[k]) { scene.remove(chunkMeshes[k]); clickables = clickables.filter(c => c !== chunkMeshes[k]); delete chunkMeshes[k]; }
            const m = buildChunk(cx, cz);
            if(m) { scene.add(m); clickables.push(m); chunkMeshes[k] = m; }
        }

        // --- Core Game Logic ---
        function checkCol(p) {
            const r = PLAYER_RADIUS;
            for(let y = Math.floor(p.y - PLAYER_HEIGHT + 0.1); y <= Math.floor(p.y + 0.1); y++) {
                for(let x = Math.floor(p.x - r); x <= Math.floor(p.x + r); x++) {
                    for(let z = Math.floor(p.z - r); z <= Math.floor(p.z + r); z++) {
                        const b = getBlock(x, y, z);
                        if(b !== 0 && b !== 11 && b !== 10) return true;
                    }
                }
            }
            return false;
        }

        function interact(place) {
            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects(clickables);
            if(hits.length > 0) {
                const h = hits[0], n = h.face.normal;
                const bx = Math.floor(h.point.x - n.x*0.05), by = Math.floor(h.point.y - n.y*0.05), bz = Math.floor(h.point.z - n.z*0.05);
                const pbx = Math.floor(h.point.x + n.x*0.05), pby = Math.floor(h.point.y + n.y*0.05), pbz = Math.floor(h.point.z + n.z*0.05);
                if(place) {
                    const id = hotbarSlots[activeHotbarIndex];
                    if(id === 0 || getBlock(pbx, pby, pbz) !== 0) return;
                    world[`${pbx},${pby},${pbz}`] = id; refreshChunk(pbx, pbz);
                    addDoc(collection(db, 'artifacts', APP_ID, 'public', 'data', 'world_changes'), { x: pbx, y: pby, z: pbz, id, action: 'PLACE', timestamp: serverTimestamp() });
                } else {
                    const type = getBlock(bx, by, bz);
                    if(type === 0 || BLOCKS[type]?.indestructible) return;
                    world[`${bx},${by},${bz}`] = 0; refreshChunk(bx, bz);
                    addDoc(collection(db, 'artifacts', APP_ID, 'public', 'data', 'world_changes'), { x: bx, y: by, z: bz, action: 'BREAK', timestamp: serverTimestamp() });
                }
            }
        }

        function updatePOV() {
            if (povMode === 0) { camera.position.set(0, 0, 0); if(robotModel) robotModel.visible = false; }
            else if (povMode === 1) { camera.position.set(0, 0.5, povDist); if(robotModel) robotModel.visible = true; }
            else { camera.position.set(0, 0.5, -povDist); camera.rotation.y = Math.PI; if(robotModel) robotModel.visible = true; }
        }

        function animate() {
            if(!running) return;
            requestAnimationFrame(animate);
            if(paused) { renderer.render(scene, camera); return; }
            
            const now = performance.now(), dt = Math.min((now - last) / 1000, 0.1); last = now;
            if(mixer) mixer.update(dt);

            if(isFlying) {
                let fv = 0; if(keys[' '] || isTouchingUp) fv += 1; if(keys['shift'] || isTouchingDown) fv -= 1;
                vel.y = fv * 12;
            } else { vel.y -= 25 * dt; }

            const r = playerGroup.rotation.y, speed = (isFlying ? 15 : 6.5);
            let mx=0, mz=0;
            if(isTouch) { mx = joy.x; mz = joy.y; }
            else { if(keys.w)mz=-1; if(keys.s)mz=1; if(keys.a)mx=-1; if(keys.d)mx=1; }
            
            const dx = (Math.sin(r)*mz + Math.cos(r)*mx) * speed, dz = (Math.cos(r)*mz - Math.sin(r)*mx) * speed;
            
            playerGroup.position.x += dx*dt; if(checkCol(playerGroup.position)) playerGroup.position.x -= dx*dt;
            playerGroup.position.z += dz*dt; if(checkCol(playerGroup.position)) playerGroup.position.z -= dz*dt;
            playerGroup.position.y += vel.y*dt;
            
            if(checkCol(playerGroup.position)) {
                if(vel.y < 0) { playerGroup.position.y = Math.ceil(playerGroup.position.y - PLAYER_HEIGHT) + PLAYER_HEIGHT; vel.y = 0; onGround = true; }
                else { playerGroup.position.y -= vel.y*dt; vel.y = 0; }
            } else { onGround = false; }

            if(mixer) {
                const isMoving = Math.hypot(dx, dz) > 0.5;
                const nextAct = isMoving ? 'Walking' : 'Idle';
                if(activeAction?._clip.name !== nextAct) {
                    const prev = activeAction; activeAction = actions[nextAct];
                    if(prev) prev.fadeOut(0.2);
                    if(activeAction) activeAction.reset().fadeIn(0.2).play();
                }
            }

            gameTime += dt; const angle = ((gameTime % DAY_LENGTH_SECONDS) / DAY_LENGTH_SECONDS) * Math.PI * 2;
            sunLight.position.set(Math.sin(angle)*100, Math.cos(angle)*100, 50);
            const sky = Math.cos(angle) > 0 ? new THREE.Color(0x87CEEB) : new THREE.Color(0x050510);
            scene.background = sky; scene.fog.color = sky;
            stars.material.opacity = Math.max(0, -Math.cos(angle));

            raycaster.setFromCamera({x:0, y:0}, camera);
            const hit = raycaster.intersectObjects(clickables)[0];
            if(hit) {
                const n = hit.face.normal;
                selectionBox.position.set(Math.floor(hit.point.x-n.x*0.1)+0.5, Math.floor(hit.point.y-n.y*0.1)+0.5, Math.floor(hit.point.z-n.z*0.1)+0.5);
                selectionBox.visible = true;
            } else selectionBox.visible = false;

            for(let id in otherPlayers) {
                const p = otherPlayers[id];
                p.group.position.lerp(p.targetPos, 0.2);
                p.group.rotation.y = THREE.MathUtils.lerp(p.group.rotation.y, p.targetRot, 0.2);
                if(p.mixer) p.mixer.update(dt);
            }

            updateNetworkLoop();
            updateWorld();
            renderer.render(scene, camera);
        }

        function updateWorld() {
            const px = Math.floor(playerGroup.position.x/CHUNK_SIZE), pz = Math.floor(playerGroup.position.z/CHUNK_SIZE);
            for(let x=px-RENDER_DIST; x<=px+RENDER_DIST; x++) {
                for(let z=pz-RENDER_DIST; z<=pz+RENDER_DIST; z++) {
                    if(!chunkMeshes[`${x},${z}`]) refreshChunk(x*CHUNK_SIZE, z*CHUNK_SIZE);
                }
            }
        }

        async function init() {
            atlas = await createAtlas();
            scene = new THREE.Scene(); scene.fog = new THREE.Fog(0x87CEEB, 30, 80);
            playerGroup = new THREE.Group(); scene.add(playerGroup);
            cameraPivot = new THREE.Group(); playerGroup.add(cameraPivot);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); cameraPivot.add(camera);
            
            renderer = new THREE.WebGLRenderer({ antialias: false }); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 1.5 : 1);
            document.body.appendChild(renderer.domElement);
            
            scene.add(ambientLight = new THREE.AmbientLight(0xffffff, 0.6));
            scene.add(sunLight = new THREE.DirectionalLight(0xffffff, 0.8));
            
            raycaster = new THREE.Raycaster();
            selectionBox = new THREE.Mesh(new THREE.BoxGeometry(1.01, 1.01, 1.01), new THREE.MeshBasicMaterial({ color: 0, wireframe: true }));
            scene.add(selectionBox);

            new THREE.GLTFLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/models/gltf/RobotExpressive/RobotExpressive.glb', (gltf) => {
                robotModel = gltf.scene;
                robotModel.animations = gltf.animations;
                robotModel.scale.set(0.35, 0.35, 0.35);
                robotModel.position.y = -PLAYER_HEIGHT;
                playerGroup.add(robotModel);
                mixer = new THREE.AnimationMixer(robotModel);
                gltf.animations.forEach(c => actions[c.name] = mixer.clipAction(c));
                activeAction = actions['Idle']; if(activeAction) activeAction.play();
                modelLoaded = true;
                document.getElementById('loading-text').innerText = 'READY';
                document.getElementById('start-btn').style.display = 'block';
            });

            const starGeo = new THREE.BufferGeometry(), starPts = [];
            for(let i=0; i<1500; i++) starPts.push((Math.random()-0.5)*400, Math.random()*200, (Math.random()-0.5)*400);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPts, 3));
            stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.3, transparent: true}));
            scene.add(stars);

            setupControls();
            updateUI();
        }

        function setupControls() {
            window.onkeydown = e => { if(document.activeElement.tagName !== 'INPUT') keys[e.key.toLowerCase()] = 1; if(e.key === ' ' && !paused) handleJump(); };
            window.onkeyup = e => keys[e.key.toLowerCase()] = 0;
            
            const handleJump = () => {
                const now = Date.now();
                if(now - lastJumpTime < 300) { isFlying = !isFlying; vel.y = 0; document.querySelectorAll('#up-btn, #down-btn').forEach(b => b.style.display = isFlying ? 'flex' : 'none'); }
                else if(!isFlying && onGround) vel.y = 10;
                lastJumpTime = now;
            };

            if(isTouch) {
                const zone = document.getElementById('joy-zone'), nub = document.getElementById('joy-nub');
                document.addEventListener('touchstart', e => {
                    for(let t of e.changedTouches) {
                        const r = zone.getBoundingClientRect();
                        if(Math.hypot(t.clientX-(r.left+r.width/2), t.clientY-(r.top+r.height/2)) < 60) { joy.id = t.identifier; joy.sx = t.clientX; joy.sy = t.clientY; }
                        else if(t.target.closest('#jump-btn')) handleJump();
                        else if(t.target.closest('#up-btn')) isTouchingUp = true;
                        else if(t.target.closest('#down-btn')) isTouchingDown = true;
                        else if(!touchState.id && t.clientX > 150) {
                            touchState.id = t.identifier; touchState.lx = t.clientX; touchState.ly = t.clientY; touchState.moved = false;
                            touchState.timer = setTimeout(() => { if(!touchState.moved) { touchState.mining = true; touchState.timer = setInterval(() => interact(false), MINE_DELAY); document.getElementById('break-progress').style.transform = 'translate(-50%,-50%) scale(1)'; } }, 250);
                        }
                    }
                });
                document.addEventListener('touchmove', e => {
                    for(let t of e.changedTouches) {
                        if(t.identifier === joy.id) {
                            const dx = t.clientX - joy.sx, dy = t.clientY - joy.sy, d = Math.min(45, Math.hypot(dx,dy)), a = Math.atan2(dy, dx);
                            joy.x = Math.cos(a)*(d/45); joy.y = Math.sin(a)*(d/45);
                            nub.style.transform = `translate(${Math.cos(a)*d - 22}px, ${Math.sin(a)*d - 22}px)`;
                        } else if(t.identifier === touchState.id) {
                            if(Math.hypot(t.clientX-touchState.lx, t.clientY-touchState.ly) > 5) {
                                touchState.moved = true; 
                                playerGroup.rotation.y -= (t.clientX - touchState.lx) * 0.007;
                                cameraPivot.rotation.x = Math.max(-1.5, Math.min(1.5, cameraPivot.rotation.x - (t.clientY - touchState.ly) * 0.007));
                                touchState.lx = t.clientX; touchState.ly = t.clientY;
                            }
                        }
                    }
                });
                document.addEventListener('touchend', e => {
                    for(let t of e.changedTouches) {
                        if(t.identifier === joy.id) { joy.id = null; joy.x = 0; joy.y = 0; nub.style.transform = 'translate(-50%,-50%)'; }
                        else if(t.identifier === touchState.id) {
                            if(!touchState.moved) interact(true);
                            clearTimeout(touchState.timer); clearInterval(touchState.timer);
                            document.getElementById('break-progress').style.transform = 'translate(-50%,-50%) scale(0)';
                            touchState.id = null;
                        } else if(t.target.closest('#up-btn')) isTouchingUp = false;
                        else if(t.target.closest('#down-btn')) isTouchingDown = false;
                    }
                });
            } else {
                document.body.onclick = () => { if(running && !paused) document.body.requestPointerLock(); };
                document.body.onmousemove = e => { if(document.pointerLockElement) { playerGroup.rotation.y -= e.movementX*0.002; cameraPivot.rotation.x = Math.max(-1.5, Math.min(1.5, cameraPivot.rotation.x - e.movementY*0.002)); } };
                document.onmousedown = e => {
                    if(!document.pointerLockElement || paused) return;
                    if(e.button === 0) {
                        interact(false); touchState.timer = setInterval(() => interact(false), MINE_DELAY);
                        document.getElementById('break-progress').style.transform = 'translate(-50%,-50%) scale(1)';
                    } else if(e.button === 2) interact(true);
                };
                document.onmouseup = () => { clearInterval(touchState.timer); document.getElementById('break-progress').style.transform = 'translate(-50%,-50%) scale(0)'; };
            }

            document.getElementById('start-btn').onclick = async () => {
                const provider = new GoogleAuthProvider();
                try {
                    const res = await signInWithPopup(auth, provider);
                    currentUser = res.user; userId = res.user.uid; 
                    userDisplayName = res.user.displayName || 'Player';
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('user-display-id').innerText = userDisplayName;
                    initNetwork();
                    playerGroup.position.set(0, 80, 0); running = true;
                    if(isTouch) document.querySelectorAll('.ctrl').forEach(c => c.style.display = 'flex');
                    updatePOV(); animate();
                } catch(e) { console.error(e); }
            };

            document.getElementById('cam-btn').onclick = () => { povMode = (povMode + 1)%3; updatePOV(); };
            document.getElementById('inv-btn').onclick = () => { document.getElementById('inventory-overlay').style.display = 'flex'; document.exitPointerLock(); };
            document.getElementById('close-inv').onclick = () => { document.getElementById('inventory-overlay').style.display = 'none'; if(!isTouch) document.body.requestPointerLock(); };
            document.getElementById('resume-btn').onclick = () => { paused = false; document.getElementById('pause-menu').style.display = 'none'; };
            document.getElementById('pause-btn').onclick = () => { paused = true; document.getElementById('pause-menu').style.display = 'flex'; document.exitPointerLock(); };
        }

        function updateUI() {
            const hotbar = document.getElementById('hotbar-slots'); hotbar.innerHTML = '';
            hotbarSlots.forEach((id, i) => {
                const s = document.createElement('div'); s.className = 'slot' + (i === activeHotbarIndex ? ' active' : '');
                const c = document.createElement('canvas'); c.width = 30; c.height = 30;
                if(id > 0) {
                    const ctx = c.getContext('2d'); const tIdx = BLOCKS[id].tiles[2];
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(atlas.image, (tIdx%8)*32, Math.floor(tIdx/8)*32, 32, 32, 0, 0, 30, 30);
                }
                s.appendChild(c); s.onclick = () => { activeHotbarIndex = i; updateUI(); };
                hotbar.appendChild(s);
            });

            const grid = document.getElementById('inventory-grid'); grid.innerHTML = '';
            Object.keys(BLOCKS).forEach(id => {
                const s = document.createElement('div'); s.className = 'slot';
                const c = document.createElement('canvas'); c.width = 30; c.height = 30;
                const ctx = c.getContext('2d'); const tIdx = BLOCKS[id].tiles[2];
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(atlas.image, (tIdx%8)*32, Math.floor(tIdx/8)*32, 32, 32, 0, 0, 30, 30);
                s.appendChild(c); s.onclick = () => { hotbarSlots[activeHotbarIndex] = parseInt(id); updateUI(); };
                grid.appendChild(s);
            });
        }

        let last = performance.now();
        init();
    </script>
</body>
</html>

